<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Stridelab ‚Äî Analysis</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèÉ</text></svg>">
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Syne:wght@300;400;700;800&display=swap" rel="stylesheet"/>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg:      #050507;
    --surface: #0d0d12;
    --border:  #1a1a24;
    --text:    #e8e8f0;
    --muted:   #44445a;
    --accent:  #e8ff47;
    --cyan:    #00f5ff;
    --purple:  #6366f1;
    --purple-border: rgba(99, 102, 241, 0.5);
  }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Syne', sans-serif;
    font-weight: 300;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 32px 24px;
    background-image:
      linear-gradient(rgba(0,245,255,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,245,255,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
  }

  .logo {
    font-family: 'Space Mono', monospace;
    font-size: 0.7rem;
    font-weight: 400;
    letter-spacing: 0.4em;
    text-transform: uppercase;
    color: var(--cyan);
    margin-bottom: 36px;
    opacity: 0.7;
    text-decoration: none;
  }

  .container {
    width: 100%;
    max-width: 1100px;
    animation: fadeUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) both;
  }

  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(24px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  /* ‚îÄ‚îÄ Loading state ‚îÄ‚îÄ */
  .loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 18px;
    padding: 80px 0;
  }
  .loading.hidden { display: none; }

  .loading-spinner {
    width: 40px; height: 40px;
    border: 2px solid var(--border);
    border-top-color: var(--cyan);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  .loading-text {
    font-family: 'Space Mono', monospace;
    font-size: 0.72rem;
    color: var(--muted);
    letter-spacing: 0.1em;
  }

  /* ‚îÄ‚îÄ Kinogram section ‚îÄ‚îÄ */
  .kinogram { display: none; }
  .kinogram.visible { display: block; }

  .section-title {
    font-family: 'Syne', sans-serif;
    font-size: 1.1rem;
    font-weight: 800;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--text);
    margin-bottom: 20px;
    background: linear-gradient(135deg, #fff 0%, rgba(255,255,255,0.5) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  /* Phase labels row */
  .phase-labels {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 8px;
    margin-bottom: 8px;
  }

  .phase-label {
    font-family: 'Syne', sans-serif;
    font-size: 0.68rem;
    font-weight: 700;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    text-align: center;
    color: var(--muted);
  }

  /* Filmstrip grid */
  .filmstrip {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 8px;
    margin-bottom: 8px;
  }

  .frame-cell {
    aspect-ratio: 16 / 10;
    background: var(--surface);
    border: 2px solid var(--purple-border);
    border-radius: 4px;
    overflow: hidden;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .frame-cell img,
  .frame-cell canvas {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }

  /* Placeholder skeleton while loading frames */
  .frame-cell .placeholder {
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, var(--surface) 25%, #151520 50%, var(--surface) 75%);
    background-size: 200% 100%;
    animation: shimmer-load 1.5s infinite;
  }

  @keyframes shimmer-load {
    from { background-position: 200% 0; }
    to   { background-position: -200% 0; }
  }

  /* Row labels */
  .row-label {
    font-family: 'Space Mono', monospace;
    font-size: 0.6rem;
    color: var(--muted);
    letter-spacing: 0.1em;
    margin-bottom: 14px;
    text-transform: uppercase;
  }

  /* ‚îÄ‚îÄ Error state ‚îÄ‚îÄ */
  .error-state {
    display: none;
    text-align: center;
    padding: 60px 0;
  }
  .error-state.visible { display: block; }
  .error-state p {
    font-family: 'Space Mono', monospace;
    font-size: 0.78rem;
    color: #ff7788;
    margin-bottom: 20px;
  }
  .error-state a {
    font-family: 'Syne', sans-serif;
    font-size: 0.78rem;
    color: var(--cyan);
    text-decoration: none;
    border: 1px solid var(--cyan);
    padding: 10px 24px;
    transition: background 0.2s, color 0.2s;
  }
  .error-state a:hover {
    background: var(--cyan);
    color: var(--bg);
  }

  /* ‚îÄ‚îÄ Back link ‚îÄ‚îÄ */
  .back-link {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-family: 'Space Mono', monospace;
    font-size: 0.68rem;
    color: var(--muted);
    text-decoration: none;
    margin-bottom: 28px;
    letter-spacing: 0.06em;
    transition: color 0.2s;
  }
  .back-link:hover { color: var(--cyan); }

  @media (max-width: 700px) {
    .phase-labels, .filmstrip {
      grid-template-columns: repeat(3, 1fr);
    }
  }
</style>
</head>
<body>

<a class="logo" href="/">Stridelab</a>

<div class="container">
  <a class="back-link" href="/">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="15 18 9 12 15 6"/>
    </svg>
    Back
  </a>

  <!-- Loading -->
  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
    <div class="loading-text">Loading analysis‚Ä¶</div>
  </div>

  <!-- Error -->
  <div class="error-state" id="error-state">
    <p id="error-text">Could not load analysis data.</p>
    <a href="/">Upload another video</a>
  </div>

  <!-- Kinogram -->
  <div class="kinogram" id="kinogram">
    <div class="section-title">Running Kinogram</div>

    <!-- Phase column headers -->
    <div class="phase-labels">
      <div class="phase-label">MVP</div>
      <div class="phase-label">Strike</div>
      <div class="phase-label">Touch Down</div>
      <div class="phase-label">Full Support</div>
      <div class="phase-label">Mid Swing</div>
      <div class="phase-label">Toe Off</div>
    </div>

    <!-- Row 1: Stride 1 -->
    <div class="row-label" id="row1-label">Stride 1</div>
    <div class="filmstrip" id="filmstrip-row1">
      <div class="frame-cell"><div class="placeholder"></div></div>
      <div class="frame-cell"><div class="placeholder"></div></div>
      <div class="frame-cell"><div class="placeholder"></div></div>
      <div class="frame-cell"><div class="placeholder"></div></div>
      <div class="frame-cell"><div class="placeholder"></div></div>
      <div class="frame-cell"><div class="placeholder"></div></div>
    </div>

    <!-- Row 2: Stride 2 -->
    <div class="row-label" id="row2-label">Stride 2</div>
    <div class="filmstrip" id="filmstrip-row2">
      <div class="frame-cell"><div class="placeholder"></div></div>
      <div class="frame-cell"><div class="placeholder"></div></div>
      <div class="frame-cell"><div class="placeholder"></div></div>
      <div class="frame-cell"><div class="placeholder"></div></div>
      <div class="frame-cell"><div class="placeholder"></div></div>
      <div class="frame-cell"><div class="placeholder"></div></div>
    </div>
  </div>
</div>

<!-- Hidden video for frame capture -->
<video id="hidden-video" style="display:none;" crossorigin="anonymous" preload="auto"></video>

<script>
  const params = new URLSearchParams(window.location.search);
  const jobId  = params.get("job");

  const PHASES = ["MVP", "Strike", "Touch Down", "Full Support", "Mid Swing", "Toe Off"];

  // Approximate % positions within a gait cycle for each phase
  const PHASE_OFFSETS = [0.0, 0.15, 0.25, 0.40, 0.65, 0.85];

  const loadingEl  = document.getElementById("loading");
  const errorEl    = document.getElementById("error-state");
  const errorText  = document.getElementById("error-text");
  const kinogramEl = document.getElementById("kinogram");
  const video      = document.getElementById("hidden-video");

  function showError(msg) {
    loadingEl.classList.add("hidden");
    errorText.textContent = msg;
    errorEl.classList.add("visible");
  }

  // ‚îÄ‚îÄ Clean & interpolate an angle time-series ‚îÄ‚îÄ
  function cleanSeries(frames, angleKey) {
    const raw = frames.map(f => (f.angles && f.angles[angleKey]) ?? null);

    // Interpolate nulls
    for (let i = 0; i < raw.length; i++) {
      if (raw[i] !== null) continue;
      let before = i - 1;
      while (before >= 0 && raw[before] === null) before--;
      let after = i + 1;
      while (after < raw.length && raw[after] === null) after++;
      if (before >= 0 && after < raw.length) {
        raw[i] = raw[before] + (raw[after] - raw[before]) * ((i - before) / (after - before));
      } else if (before >= 0) {
        raw[i] = raw[before];
      } else if (after < raw.length) {
        raw[i] = raw[after];
      } else {
        raw[i] = 0;
      }
    }

    // Heavy smoothing (window = 7) to kill noise
    const out = [];
    const w = 7;
    for (let i = 0; i < raw.length; i++) {
      let sum = 0, n = 0;
      for (let j = Math.max(0, i - w); j <= Math.min(raw.length - 1, i + w); j++) {
        sum += raw[j]; n++;
      }
      out.push(sum / n);
    }
    return out;
  }

  // ‚îÄ‚îÄ Find peaks with prominence filtering ‚îÄ‚îÄ
  function findProminentPeaks(values, minDistFrames) {
    // Step 1: find ALL local maxima
    const candidates = [];
    for (let i = 2; i < values.length - 2; i++) {
      if (values[i] > values[i - 1] && values[i] > values[i + 1] &&
          values[i] > values[i - 2] && values[i] > values[i + 2]) {
        candidates.push(i);
      }
    }
    if (candidates.length === 0) return [];

    // Step 2: compute prominence for each candidate
    const globalMin = Math.min(...values);
    const globalMax = Math.max(...values);
    const range = globalMax - globalMin || 1;

    const withProm = candidates.map(idx => {
      // Find the lowest valley on each side before hitting a higher peak
      let leftMin = values[idx], rightMin = values[idx];
      for (let j = idx - 1; j >= 0; j--) {
        leftMin = Math.min(leftMin, values[j]);
        if (values[j] > values[idx]) break;
      }
      for (let j = idx + 1; j < values.length; j++) {
        rightMin = Math.min(rightMin, values[j]);
        if (values[j] > values[idx]) break;
      }
      const prominence = values[idx] - Math.max(leftMin, rightMin);
      return { idx, prominence };
    });

    // Step 3: keep only peaks with prominence > 15% of total range
    const minProm = range * 0.15;
    const strong = withProm
      .filter(p => p.prominence >= minProm)
      .sort((a, b) => b.prominence - a.prominence);

    // Step 4: enforce minimum distance (greedy, highest prominence first)
    const selected = [];
    for (const peak of strong) {
      const tooClose = selected.some(s => Math.abs(s - peak.idx) < minDistFrames);
      if (!tooClose) selected.push(peak.idx);
    }

    return selected.sort((a, b) => a - b);
  }

  // ‚îÄ‚îÄ Detect gait cycles from hip angle data ‚îÄ‚îÄ
  function detectGaitCycles(frames, angleKey, fps) {
    const smoothed = cleanSeries(frames, angleKey);

    // Minimum distance between peaks: a full stride at max sprint is ~0.3s,
    // so require at least 0.35s between peaks
    const minDist = Math.max(8, Math.floor(fps * 0.35));
    const peaks = findProminentPeaks(smoothed, minDist);

    console.log(`[${angleKey}] Found ${peaks.length} prominent peaks:`, peaks);

    // Build cycles (peak to peak)
    const cycles = [];
    for (let i = 0; i < peaks.length - 1; i++) {
      const startFrame = peaks[i];
      const endFrame   = peaks[i + 1];
      const duration   = endFrame - startFrame;
      const durationSec = duration / fps;
      // Accept cycles between 0.25s and 2.0s
      if (durationSec >= 0.25 && durationSec <= 2.0) {
        cycles.push({ startFrame, endFrame, duration });
        console.log(`  Cycle: frame ${startFrame}‚Üí${endFrame} (${durationSec.toFixed(2)}s)`);
      }
    }

    return cycles;
  }

  // ‚îÄ‚îÄ Fallback: evenly spaced frames across the video ‚îÄ‚îÄ
  function evenlySpacedCycles(totalFrames, fps) {
    // Split the middle 70% of the video into two halves for the two rows
    const start = Math.floor(totalFrames * 0.15);
    const end   = Math.floor(totalFrames * 0.85);
    const mid   = Math.floor((start + end) / 2);
    const dur1  = mid - start;
    const dur2  = end - mid;

    console.log("Fallback: using evenly spaced frames");
    return [
      { startFrame: start, endFrame: mid, duration: dur1 },
      { startFrame: mid,   endFrame: end, duration: dur2 },
    ];
  }

  // ‚îÄ‚îÄ Capture a single frame from the video at a given time ‚îÄ‚îÄ
  function captureFrame(videoEl, time) {
    return new Promise((resolve, reject) => {
      // Clamp to valid range
      const t = Math.max(0, Math.min(time, videoEl.duration - 0.05));
      const timeout = setTimeout(() => {
        videoEl.removeEventListener("seeked", onSeeked);
        reject(new Error("Seek timeout"));
      }, 5000);

      const onSeeked = () => {
        clearTimeout(timeout);
        videoEl.removeEventListener("seeked", onSeeked);
        // Small delay to ensure the frame is rendered
        requestAnimationFrame(() => {
          try {
            const canvas = document.createElement("canvas");
            canvas.width  = videoEl.videoWidth;
            canvas.height = videoEl.videoHeight;
            canvas.getContext("2d").drawImage(videoEl, 0, 0);
            resolve(canvas.toDataURL("image/jpeg", 0.85));
          } catch (e) {
            reject(e);
          }
        });
      };

      videoEl.addEventListener("seeked", onSeeked);
      videoEl.currentTime = t;
    });
  }

  // ‚îÄ‚îÄ Fill a filmstrip row with captured frames ‚îÄ‚îÄ
  async function fillRow(rowEl, cycle, fps) {
    const cells = rowEl.querySelectorAll(".frame-cell");

    for (let i = 0; i < PHASE_OFFSETS.length; i++) {
      const frameIdx = cycle.startFrame + Math.round(PHASE_OFFSETS[i] * cycle.duration);
      const time     = frameIdx / fps;

      console.log(`  ${PHASES[i]}: frame ${frameIdx}, time ${time.toFixed(3)}s`);

      try {
        const dataUrl = await captureFrame(video, time);
        const img     = document.createElement("img");
        img.src       = dataUrl;
        img.alt       = PHASES[i];
        cells[i].innerHTML = "";
        cells[i].appendChild(img);
      } catch (e) {
        console.warn(`Failed to capture frame for ${PHASES[i]}:`, e);
      }
    }
  }

  // ‚îÄ‚îÄ Main ‚îÄ‚îÄ
  async function init() {
    if (!jobId) {
      showError("No job ID provided.");
      return;
    }

    let analysisOk = false;
    let fps = 30;
    let totalFrames = 0;
    let cycle1 = null, cycle2 = null;

    // 1. Try to fetch analysis data for smart cycle detection
    try {
      const res = await fetch(`/analysis-data/${jobId}`);
      if (res.ok) {
        const analysis = await res.json();
        fps = analysis.fps || 30;
        const frames = analysis.frames || [];
        totalFrames = frames.length;

        if (frames.length > 0) {
          analysisOk = true;
          console.log(`Analysis data: ${frames.length} frames at ${fps} fps`);

          // Try R Hip first, then L Hip
          const rCycles = detectGaitCycles(frames, "R Hip", fps);
          const lCycles = detectGaitCycles(frames, "L Hip", fps);

          console.log(`R Hip cycles: ${rCycles.length}, L Hip cycles: ${lCycles.length}`);

          // Pick the best cycle from each (prefer middle of video for clearest stride)
          if (rCycles.length > 0) {
            cycle1 = rCycles[Math.floor(rCycles.length / 2)];
          }
          if (lCycles.length > 0) {
            // Try to pick a left cycle that doesn't overlap too much with cycle1
            for (const lc of lCycles) {
              if (!cycle1 || Math.abs(lc.startFrame - cycle1.startFrame) > cycle1.duration * 0.3) {
                cycle2 = lc;
                break;
              }
            }
            if (!cycle2) cycle2 = lCycles[Math.floor(lCycles.length / 2)];
          }

          // If only one side had cycles, use a second cycle from the same side
          if (cycle1 && !cycle2 && rCycles.length > 1) {
            const idx = Math.floor(rCycles.length / 2);
            cycle2 = rCycles[idx + 1] || rCycles[idx - 1] || rCycles[0];
            if (cycle2 === cycle1 && rCycles.length > 1) cycle2 = rCycles[rCycles.length - 1];
          }
          if (!cycle1 && cycle2 && lCycles.length > 1) {
            const idx = Math.floor(lCycles.length / 2);
            cycle1 = lCycles[idx + 1] || lCycles[idx - 1] || lCycles[0];
            if (cycle1 === cycle2 && lCycles.length > 1) cycle1 = lCycles[0];
          }
        }
      }
    } catch (e) {
      console.warn("Could not fetch analysis data:", e);
    }

    // 2. Load the processed video
    try {
      await new Promise((resolve, reject) => {
        video.addEventListener("canplaythrough", resolve, { once: true });
        video.addEventListener("error", () => reject(new Error("Failed to load video.")), { once: true });
        video.src = `/download/${jobId}`;
        video.load();
      });
    } catch (err) {
      showError("Failed to load the processed video.");
      return;
    }

    // Wait a moment for video to become seekable
    await new Promise(r => setTimeout(r, 800));

    console.log(`Video loaded: ${video.duration.toFixed(2)}s, ${video.videoWidth}x${video.videoHeight}`);

    // 3. Fallback to evenly spaced frames if cycle detection failed
    if (!cycle1 && !cycle2) {
      const vidFrames = Math.floor(video.duration * fps);
      const fallback = evenlySpacedCycles(vidFrames, fps);
      cycle1 = fallback[0];
      cycle2 = fallback[1];
    }

    // If we still only have one, create a second from the other half
    if (cycle1 && !cycle2) {
      const vidFrames = Math.floor(video.duration * fps);
      // Place second cycle after the first one
      const start2 = Math.min(cycle1.endFrame + 2, vidFrames - 10);
      const end2   = Math.min(start2 + cycle1.duration, vidFrames);
      if (end2 - start2 > 4) {
        cycle2 = { startFrame: start2, endFrame: end2, duration: end2 - start2 };
      }
    }

    // 4. Show kinogram and fill frames
    loadingEl.classList.add("hidden");
    kinogramEl.classList.add("visible");

    const row1El    = document.getElementById("filmstrip-row1");
    const row2El    = document.getElementById("filmstrip-row2");
    const row1Label = document.getElementById("row1-label");
    const row2Label = document.getElementById("row2-label");

    if (cycle1) {
      row1Label.textContent = analysisOk ? "Stride 1 ‚Äî Right" : "Stride 1";
      console.log("Filling row 1:", cycle1);
      await fillRow(row1El, cycle1, fps);
    }

    if (cycle2) {
      row2Label.textContent = analysisOk ? "Stride 2 ‚Äî Left" : "Stride 2";
      console.log("Filling row 2:", cycle2);
      await fillRow(row2El, cycle2, fps);
    }
  }

  init();
</script>
</body>
</html>
