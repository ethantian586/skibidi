<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Stridelab ‚Äî Analysis</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèÉ</text></svg>">
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Syne:wght@300;400;700;800&display=swap" rel="stylesheet"/>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
<<<<<<< HEAD
    --bg: #030308; --surface: #0a0a14; --border: #1a1a2e; --text: #e8e8f0;
    --muted: #3a3a5c; --accent: #e8ff47; --cyan: #00f5ff; --purple: #6366f1;
    --purple-border: rgba(99,102,241,0.45);
=======
    --bg:      #030308;
    --surface: #0a0a14;
    --border:  #1a1a2e;
    --text:    #e8e8f0;
    --muted:   #3a3a5c;
    --accent:  #e8ff47;
    --cyan:    #00f5ff;
    --purple:  #6366f1;
    --purple-border: rgba(99, 102, 241, 0.45);
    --glow-cyan: rgba(0, 245, 255, 0.15);
    --glow-purple: rgba(99, 102, 241, 0.2);
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
  }
  body {
<<<<<<< HEAD
    background: var(--bg); color: var(--text); font-family: 'Syne', sans-serif;
    font-weight: 300; min-height: 100vh; display: flex; flex-direction: column;
    align-items: center; padding: 32px 24px; position: relative; overflow: hidden;
  }
  #bg-canvas { position: fixed; inset: 0; z-index: 0; pointer-events: none; }
  .aurora {
    position: fixed; top: -30%; left: -20%; width: 140%; height: 70%;
=======
    background: var(--bg);
    color: var(--text);
    font-family: 'Syne', sans-serif;
    font-weight: 300;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 32px 24px;
    position: relative;
    overflow: hidden;
  }

  /* Animated background canvas */
  #bg-canvas {
    position: fixed;
    inset: 0;
    z-index: 0;
    pointer-events: none;
  }

  /* Animated aurora glow */
  .aurora {
    position: fixed;
    top: -30%;
    left: -20%;
    width: 140%;
    height: 70%;
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
    background:
      radial-gradient(ellipse 50% 60% at 30% 50%, rgba(99,102,241,0.08) 0%, transparent 70%),
      radial-gradient(ellipse 50% 60% at 70% 50%, rgba(0,245,255,0.06) 0%, transparent 70%);
    animation: aurora-drift 12s ease-in-out infinite alternate;
<<<<<<< HEAD
    pointer-events: none; z-index: 0; filter: blur(40px);
=======
    pointer-events: none;
    z-index: 0;
    filter: blur(40px);
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
  }
  @keyframes aurora-drift {
    0%   { transform: translateX(-5%) translateY(0%) rotate(-2deg); opacity: 0.6; }
    33%  { transform: translateX(3%) translateY(3%) rotate(1deg); opacity: 1; }
    66%  { transform: translateX(-2%) translateY(-2%) rotate(-1deg); opacity: 0.7; }
    100% { transform: translateX(5%) translateY(1%) rotate(2deg); opacity: 0.9; }
  }
<<<<<<< HEAD
  body::after {
    content: ''; position: fixed; inset: 0;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,245,255,0.008) 2px, rgba(0,245,255,0.008) 4px);
    pointer-events: none; z-index: 9999;
  }
  .logo, .container { position: relative; z-index: 1; }
  .logo {
    font-family: 'Space Mono', monospace; font-size: 0.7rem; font-weight: 400;
    letter-spacing: 0.4em; text-transform: uppercase; color: var(--cyan);
    margin-bottom: 36px; text-decoration: none;
    text-shadow: 0 0 12px rgba(0,245,255,0.5); transition: text-shadow 0.3s;
  }
  .logo:hover { text-shadow: 0 0 20px rgba(0,245,255,0.8); }
  .container { width: 100%; max-width: 1100px; animation: fadeUp 0.6s cubic-bezier(0.16,1,0.3,1) both; }
  @keyframes fadeUp { from { opacity: 0; transform: translateY(24px); } to { opacity: 1; transform: translateY(0); } }
  .back-link {
    display: inline-flex; align-items: center; gap: 6px;
    font-family: 'Space Mono', monospace; font-size: 0.62rem; color: var(--muted);
    text-decoration: none; margin-bottom: 24px; letter-spacing: 0.08em;
    text-transform: uppercase; transition: color 0.2s, text-shadow 0.2s;
=======

  /* Subtle scan line overlay */
  body::after {
    content: '';
    position: fixed;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0, 245, 255, 0.008) 2px,
      rgba(0, 245, 255, 0.008) 4px
    );
    pointer-events: none;
    z-index: 9999;
  }

  /* Ensure content sits above background */
  .logo, .container { position: relative; z-index: 1; }

  .logo {
    font-family: 'Space Mono', monospace;
    font-size: 0.7rem;
    font-weight: 400;
    letter-spacing: 0.4em;
    text-transform: uppercase;
    color: var(--cyan);
    margin-bottom: 36px;
    text-decoration: none;
    text-shadow: 0 0 12px rgba(0, 245, 255, 0.5);
    transition: text-shadow 0.3s;
  }
  .logo:hover { text-shadow: 0 0 20px rgba(0, 245, 255, 0.8); }

  .container {
    width: 100%;
    max-width: 1100px;
    animation: fadeUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) both;
  }

  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(24px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  /* ‚îÄ‚îÄ Loading state ‚îÄ‚îÄ */
  .loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
    padding: 100px 0;
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
  }
  .back-link:hover { color: var(--cyan); text-shadow: 0 0 8px rgba(0,245,255,0.4); }
  .loading { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; padding: 100px 0; }
  .loading.hidden { display: none; }
  .loading-spinner {
<<<<<<< HEAD
    width: 48px; height: 48px; border: 2px solid transparent;
    border-top-color: var(--cyan); border-right-color: rgba(99,102,241,0.5);
    border-radius: 50%; animation: spin 0.7s linear infinite;
=======
    width: 48px; height: 48px;
    border: 2px solid transparent;
    border-top-color: var(--cyan);
    border-right-color: rgba(99,102,241,0.5);
    border-radius: 50%;
    animation: spin 0.7s linear infinite;
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
    filter: drop-shadow(0 0 8px rgba(0,245,255,0.4));
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  .loading-text {
<<<<<<< HEAD
    font-family: 'Space Mono', monospace; font-size: 0.72rem; color: var(--cyan);
    letter-spacing: 0.14em; text-transform: uppercase; opacity: 0.7;
    animation: pulse-text 2s ease-in-out infinite;
=======
    font-family: 'Space Mono', monospace;
    font-size: 0.72rem;
    color: var(--cyan);
    letter-spacing: 0.14em;
    text-transform: uppercase;
    opacity: 0.7;
    animation: pulse-text 2s ease-in-out infinite;
  }
  @keyframes pulse-text {
    0%, 100% { opacity: 0.5; }
    50%      { opacity: 1; }
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
  }
  @keyframes pulse-text { 0%,100% { opacity: 0.5; } 50% { opacity: 1; } }
  .kinogram { display: none; }
  .kinogram.visible { display: block; }
<<<<<<< HEAD
  .hud-panel {
    background: linear-gradient(180deg, rgba(10,10,20,0.95) 0%, rgba(6,6,14,0.98) 100%);
    border: 1px solid var(--border); padding: 28px 24px 24px; position: relative; margin-bottom: 0;
  }
  .hud-panel::before, .hud-panel::after {
    content: ''; position: absolute; width: 20px; height: 20px;
    border-color: var(--cyan); border-style: solid; opacity: 0.6;
  }
  .hud-panel::before { top: -1px; left: -1px; border-width: 2px 0 0 2px; }
  .hud-panel::after  { top: -1px; right: -1px; border-width: 2px 2px 0 0; }
  .hud-corners-bottom { position: absolute; bottom: 0; left: 0; right: 0; height: 0; pointer-events: none; }
  .hud-corners-bottom::before, .hud-corners-bottom::after {
    content: ''; position: absolute; width: 20px; height: 20px;
    border-color: var(--cyan); border-style: solid; opacity: 0.6;
  }
  .hud-corners-bottom::before { bottom: 0; left: -1px; border-width: 0 0 2px 2px; }
  .hud-corners-bottom::after  { bottom: 0; right: -1px; border-width: 0 2px 2px 0; }
  .hud-panel .glow-line {
    position: absolute; top: 0; left: 20px; right: 20px; height: 1px;
    background: linear-gradient(90deg, transparent, var(--cyan), transparent); opacity: 0.3;
  }
  .section-title {
    font-family: 'Syne', sans-serif; font-size: 1.2rem; font-weight: 800;
    letter-spacing: 0.12em; text-transform: uppercase; color: var(--cyan);
    margin-bottom: 6px; text-shadow: 0 0 20px rgba(0,245,255,0.3);
    display: flex; align-items: center; gap: 10px;
  }
  .section-title .tag {
    font-family: 'Space Mono', monospace; font-size: 0.55rem; font-weight: 400;
    color: var(--muted); background: rgba(99,102,241,0.1); border: 1px solid rgba(99,102,241,0.25);
    padding: 3px 8px; letter-spacing: 0.1em; text-shadow: none;
=======

  /* HUD panel wrapper */
  .hud-panel {
    background: linear-gradient(180deg, rgba(10,10,20,0.95) 0%, rgba(6,6,14,0.98) 100%);
    border: 1px solid var(--border);
    padding: 28px 24px 24px;
    position: relative;
    margin-bottom: 0;
  }

  /* Corner brackets */
  .hud-panel::before, .hud-panel::after {
    content: '';
    position: absolute;
    width: 20px; height: 20px;
    border-color: var(--cyan);
    border-style: solid;
    opacity: 0.6;
  }
  .hud-panel::before { top: -1px; left: -1px; border-width: 2px 0 0 2px; }
  .hud-panel::after  { top: -1px; right: -1px; border-width: 2px 2px 0 0; }
  .hud-panel-bottom::before { bottom: -1px; left: -1px; border-width: 0 0 2px 2px; top: auto; }
  .hud-panel-bottom::after  { bottom: -1px; right: -1px; border-width: 0 2px 2px 0; top: auto; }

  /* Extra bottom corners via inner div */
  .hud-corners-bottom {
    position: absolute;
    bottom: 0; left: 0; right: 0; height: 0;
    pointer-events: none;
  }
  .hud-corners-bottom::before, .hud-corners-bottom::after {
    content: '';
    position: absolute;
    width: 20px; height: 20px;
    border-color: var(--cyan);
    border-style: solid;
    opacity: 0.6;
  }
  .hud-corners-bottom::before { bottom: 0; left: -1px; border-width: 0 0 2px 2px; }
  .hud-corners-bottom::after  { bottom: 0; right: -1px; border-width: 0 2px 2px 0; }

  /* Glow line at top of panel */
  .hud-panel .glow-line {
    position: absolute;
    top: 0; left: 20px; right: 20px;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--cyan), transparent);
    opacity: 0.3;
  }

  .section-title {
    font-family: 'Syne', sans-serif;
    font-size: 1.2rem;
    font-weight: 800;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--cyan);
    margin-bottom: 6px;
    text-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .section-title .tag {
    font-family: 'Space Mono', monospace;
    font-size: 0.55rem;
    font-weight: 400;
    color: var(--muted);
    background: rgba(99,102,241,0.1);
    border: 1px solid rgba(99,102,241,0.25);
    padding: 3px 8px;
    letter-spacing: 0.1em;
    text-shadow: none;
  }

  .section-subtitle {
    font-family: 'Space Mono', monospace;
    font-size: 0.6rem;
    color: var(--muted);
    letter-spacing: 0.1em;
    margin-bottom: 22px;
    text-transform: uppercase;
  }

  /* Phase labels row */
  .phase-labels {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 8px;
    margin-bottom: 10px;
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
  }
  .section-subtitle {
    font-family: 'Space Mono', monospace; font-size: 0.6rem; color: var(--muted);
    letter-spacing: 0.1em; margin-bottom: 22px; text-transform: uppercase;
  }
  .phase-labels { display: grid; grid-template-columns: repeat(6,1fr); gap: 8px; margin-bottom: 10px; }
  .phase-label {
<<<<<<< HEAD
    font-family: 'Space Mono', monospace; font-size: 0.58rem; font-weight: 700;
    letter-spacing: 0.14em; text-transform: uppercase; text-align: center;
    color: var(--cyan); opacity: 0.7; padding-bottom: 6px; border-bottom: 1px solid rgba(0,245,255,0.1);
  }
  /* Detected badge ‚Äî shown when a phase was located by the algorithm */
  .phase-label.detected { opacity: 1; color: var(--accent); }
  .filmstrip { display: grid; grid-template-columns: repeat(6,1fr); gap: 8px; margin-bottom: 10px; }
  .frame-cell {
    aspect-ratio: 16/10; background: var(--surface); border: 1px solid var(--purple-border);
    overflow: hidden; position: relative; display: flex; align-items: center; justify-content: center;
    transition: border-color 0.3s, box-shadow 0.3s;
=======
    font-family: 'Space Mono', monospace;
    font-size: 0.58rem;
    font-weight: 700;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    text-align: center;
    color: var(--cyan);
    opacity: 0.7;
    padding-bottom: 6px;
    border-bottom: 1px solid rgba(0, 245, 255, 0.1);
  }

  /* Filmstrip grid */
  .filmstrip {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 8px;
    margin-bottom: 10px;
  }

  .frame-cell {
    aspect-ratio: 16 / 10;
    background: var(--surface);
    border: 1px solid var(--purple-border);
    overflow: hidden;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: border-color 0.3s, box-shadow 0.3s;
  }

  /* HUD corner brackets on each frame */
  .frame-cell::before, .frame-cell::after {
    content: '';
    position: absolute;
    width: 10px; height: 10px;
    border-color: var(--cyan);
    border-style: solid;
    opacity: 0;
    transition: opacity 0.3s;
    z-index: 2;
    pointer-events: none;
  }
  .frame-cell::before { top: 3px; left: 3px; border-width: 1px 0 0 1px; }
  .frame-cell::after  { bottom: 3px; right: 3px; border-width: 0 1px 1px 0; }

  .frame-cell:hover {
    border-color: var(--cyan);
    box-shadow: 0 0 20px rgba(0, 245, 255, 0.15), inset 0 0 20px rgba(0, 245, 255, 0.03);
  }
  .frame-cell:hover::before, .frame-cell:hover::after { opacity: 0.7; }

  /* Scan line on each frame */
  .frame-cell .scan-line {
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent, rgba(0, 245, 255, 0.4), transparent);
    animation: scan-down 3s ease-in-out infinite;
    z-index: 2;
    pointer-events: none;
    opacity: 0;
  }
  .frame-cell:hover .scan-line { opacity: 1; }

  @keyframes scan-down {
    0%   { top: 0%; }
    100% { top: 100%; }
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
  }
  .frame-cell::before, .frame-cell::after {
    content: ''; position: absolute; width: 10px; height: 10px;
    border-color: var(--cyan); border-style: solid; opacity: 0; transition: opacity 0.3s; z-index: 2; pointer-events: none;
  }
  .frame-cell::before { top: 3px; left: 3px; border-width: 1px 0 0 1px; }
  .frame-cell::after  { bottom: 3px; right: 3px; border-width: 0 1px 1px 0; }
  .frame-cell:hover { border-color: var(--cyan); box-shadow: 0 0 20px rgba(0,245,255,0.15), inset 0 0 20px rgba(0,245,255,0.03); }
  .frame-cell:hover::before, .frame-cell:hover::after { opacity: 0.7; }
  .frame-cell .scan-line {
    position: absolute; top: 0; left: 0; right: 0; height: 2px;
    background: linear-gradient(90deg, transparent, rgba(0,245,255,0.4), transparent);
    animation: scan-down 3s ease-in-out infinite; z-index: 2; pointer-events: none; opacity: 0;
  }
  .frame-cell:hover .scan-line { opacity: 1; }
  @keyframes scan-down { 0% { top: 0%; } 100% { top: 100%; } }
  .frame-cell img, .frame-cell canvas { width: 100%; height: 100%; object-fit: cover; display: block; }
  .frame-cell .placeholder {
<<<<<<< HEAD
    width: 100%; height: 100%;
    background: linear-gradient(90deg, var(--surface) 25%, rgba(99,102,241,0.06) 50%, var(--surface) 75%);
    background-size: 200% 100%; animation: shimmer-load 1.8s ease-in-out infinite; position: relative;
=======
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, var(--surface) 25%, rgba(99,102,241,0.06) 50%, var(--surface) 75%);
    background-size: 200% 100%;
    animation: shimmer-load 1.8s ease-in-out infinite;
    position: relative;
  }

  /* Crosshair in placeholder */
  .frame-cell .placeholder::before {
    content: '+';
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Space Mono', monospace;
    font-size: 1rem;
    color: var(--muted);
    opacity: 0.3;
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
  }
  .frame-cell .placeholder::before {
    content: '+'; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
    font-family: 'Space Mono', monospace; font-size: 1rem; color: var(--muted); opacity: 0.3;
  }
  @keyframes shimmer-load { from { background-position: 200% 0; } to { background-position: -200% 0; } }
  .row-label {
<<<<<<< HEAD
    font-family: 'Space Mono', monospace; font-size: 0.58rem; color: var(--accent);
    letter-spacing: 0.14em; margin-bottom: 10px; text-transform: uppercase;
    display: flex; align-items: center; gap: 10px;
=======
    font-family: 'Space Mono', monospace;
    font-size: 0.58rem;
    color: var(--accent);
    letter-spacing: 0.14em;
    margin-bottom: 10px;
    text-transform: uppercase;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .row-label::after {
    content: '';
    flex: 1;
    height: 1px;
    background: linear-gradient(90deg, rgba(232, 255, 71, 0.2), transparent);
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
  }
  .row-label::after { content: ''; flex: 1; height: 1px; background: linear-gradient(90deg, rgba(232,255,71,0.2), transparent); }

<<<<<<< HEAD
  /* Phase detection confidence indicator */
  .detect-badge {
    font-family: 'Space Mono', monospace; font-size: 0.48rem; font-weight: 700;
    letter-spacing: 0.1em; text-transform: uppercase; padding: 2px 6px;
    border: 1px solid; margin-left: auto;
=======
  /* ‚îÄ‚îÄ Error state ‚îÄ‚îÄ */
  .error-state {
    display: none;
    text-align: center;
    padding: 80px 0;
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
  }
  .detect-badge.kinematic { color: var(--accent); border-color: rgba(232,255,71,0.3); background: rgba(232,255,71,0.07); }
  .detect-badge.fallback  { color: var(--muted);  border-color: rgba(58,58,92,0.5);   background: transparent; }

  .error-state { display: none; text-align: center; padding: 80px 0; }
  .error-state.visible { display: block; }
<<<<<<< HEAD
  .error-state p { font-family: 'Space Mono', monospace; font-size: 0.78rem; color: #ff5566; margin-bottom: 24px; text-shadow: 0 0 10px rgba(255,85,102,0.3); }
  .error-state a {
    font-family: 'Space Mono', monospace; font-size: 0.7rem; color: var(--cyan);
    text-decoration: none; border: 1px solid rgba(0,245,255,0.3); padding: 10px 28px;
    letter-spacing: 0.1em; text-transform: uppercase; transition: all 0.3s;
  }
  .error-state a:hover { background: rgba(0,245,255,0.08); border-color: var(--cyan); box-shadow: 0 0 20px rgba(0,245,255,0.15); }
  .status-bar {
    display: flex; justify-content: space-between; align-items: center;
    padding-top: 14px; margin-top: 8px; border-top: 1px solid var(--border);
    font-family: 'Space Mono', monospace; font-size: 0.52rem; color: var(--muted);
    letter-spacing: 0.08em; text-transform: uppercase;
  }
  .status-bar .status-dot {
    display: inline-block; width: 5px; height: 5px; background: var(--accent);
    border-radius: 50%; margin-right: 6px; animation: blink-dot 2s ease-in-out infinite;
    box-shadow: 0 0 6px rgba(232,255,71,0.5);
  }
  @keyframes blink-dot { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
  @media (max-width: 700px) {
    .phase-labels, .filmstrip { grid-template-columns: repeat(3,1fr); }
=======
  .error-state p {
    font-family: 'Space Mono', monospace;
    font-size: 0.78rem;
    color: #ff5566;
    margin-bottom: 24px;
    text-shadow: 0 0 10px rgba(255, 85, 102, 0.3);
  }
  .error-state a {
    font-family: 'Space Mono', monospace;
    font-size: 0.7rem;
    color: var(--cyan);
    text-decoration: none;
    border: 1px solid rgba(0, 245, 255, 0.3);
    padding: 10px 28px;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    transition: all 0.3s;
  }
  .error-state a:hover {
    background: rgba(0, 245, 255, 0.08);
    border-color: var(--cyan);
    box-shadow: 0 0 20px rgba(0, 245, 255, 0.15);
  }

  /* ‚îÄ‚îÄ Back link ‚îÄ‚îÄ */
  .back-link {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-family: 'Space Mono', monospace;
    font-size: 0.62rem;
    color: var(--muted);
    text-decoration: none;
    margin-bottom: 24px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    transition: color 0.2s, text-shadow 0.2s;
  }
  .back-link:hover {
    color: var(--cyan);
    text-shadow: 0 0 8px rgba(0, 245, 255, 0.4);
  }

  /* ‚îÄ‚îÄ Status bar at bottom ‚îÄ‚îÄ */
  .status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-top: 14px;
    margin-top: 8px;
    border-top: 1px solid var(--border);
    font-family: 'Space Mono', monospace;
    font-size: 0.52rem;
    color: var(--muted);
    letter-spacing: 0.08em;
    text-transform: uppercase;
  }
  .status-bar .status-dot {
    display: inline-block;
    width: 5px; height: 5px;
    background: var(--accent);
    border-radius: 50%;
    margin-right: 6px;
    animation: blink-dot 2s ease-in-out infinite;
    box-shadow: 0 0 6px rgba(232, 255, 71, 0.5);
  }
  @keyframes blink-dot {
    0%, 100% { opacity: 1; }
    50%      { opacity: 0.3; }
  }

  @media (max-width: 700px) {
    .phase-labels, .filmstrip {
      grid-template-columns: repeat(3, 1fr);
    }
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
    .hud-panel { padding: 20px 14px 16px; }
  }
</style>
</head>
<body>

<canvas id="bg-canvas"></canvas>
<div class="aurora"></div>

<a class="logo" href="/">Stridelab</a>

<div class="container">
  <a class="back-link" href="javascript:history.back()">
    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="15 18 9 12 15 6"/>
    </svg>
    Back to results
  </a>

  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
<<<<<<< HEAD
    <div class="loading-text" id="loading-text">Extracting frames‚Ä¶</div>
=======
    <div class="loading-text">Extracting frames‚Ä¶</div>
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
  </div>

  <div class="error-state" id="error-state">
    <p id="error-text">Could not load analysis data.</p>
    <a href="/">Upload another video</a>
  </div>

  <div class="kinogram" id="kinogram">
    <div class="hud-panel">
      <div class="glow-line"></div>
      <div class="hud-corners-bottom"></div>

      <div class="section-title">
        Running Kinogram
        <span class="tag">Gait Phases</span>
      </div>
      <div class="section-subtitle">Biomechanical frame capture ‚Äî 6 key phases per stride</div>

<<<<<<< HEAD
      <div class="phase-labels" id="phase-labels-row1">
=======
      <!-- Phase column headers -->
      <div class="phase-labels">
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
        <div class="phase-label">MVP</div>
        <div class="phase-label">Strike</div>
        <div class="phase-label">Touch Down</div>
        <div class="phase-label">Full Support</div>
        <div class="phase-label">Mid Swing</div>
        <div class="phase-label">Toe Off</div>
      </div>

<<<<<<< HEAD
      <div class="row-label" id="row1-label">
        Stride 1
        <span class="detect-badge fallback" id="row1-badge">OFFSET</span>
      </div>
=======
      <!-- Row 1: Stride 1 -->
      <div class="row-label" id="row1-label">Stride 1</div>
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
      <div class="filmstrip" id="filmstrip-row1">
        <div class="frame-cell"><div class="placeholder"></div><div class="scan-line"></div></div>
        <div class="frame-cell"><div class="placeholder"></div><div class="scan-line"></div></div>
        <div class="frame-cell"><div class="placeholder"></div><div class="scan-line"></div></div>
        <div class="frame-cell"><div class="placeholder"></div><div class="scan-line"></div></div>
        <div class="frame-cell"><div class="placeholder"></div><div class="scan-line"></div></div>
        <div class="frame-cell"><div class="placeholder"></div><div class="scan-line"></div></div>
      </div>

<<<<<<< HEAD
      <div class="phase-labels" id="phase-labels-row2">
        <div class="phase-label">MVP</div>
        <div class="phase-label">Strike</div>
        <div class="phase-label">Touch Down</div>
        <div class="phase-label">Full Support</div>
        <div class="phase-label">Mid Swing</div>
        <div class="phase-label">Toe Off</div>
      </div>

      <div class="row-label" id="row2-label">
        Stride 2
        <span class="detect-badge fallback" id="row2-badge">OFFSET</span>
      </div>
=======
      <!-- Row 2: Stride 2 -->
      <div class="row-label" id="row2-label">Stride 2</div>
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
      <div class="filmstrip" id="filmstrip-row2">
        <div class="frame-cell"><div class="placeholder"></div><div class="scan-line"></div></div>
        <div class="frame-cell"><div class="placeholder"></div><div class="scan-line"></div></div>
        <div class="frame-cell"><div class="placeholder"></div><div class="scan-line"></div></div>
        <div class="frame-cell"><div class="placeholder"></div><div class="scan-line"></div></div>
        <div class="frame-cell"><div class="placeholder"></div><div class="scan-line"></div></div>
        <div class="frame-cell"><div class="placeholder"></div><div class="scan-line"></div></div>
      </div>

<<<<<<< HEAD
=======
      <!-- Status bar -->
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
      <div class="status-bar">
        <span><span class="status-dot"></span>Analysis complete</span>
        <span id="status-info">‚Äî</span>
      </div>
    </div>
  </div>
</div>

<<<<<<< HEAD
=======
<!-- Hidden video for frame capture (no crossorigin ‚Äî same-origin proxy) -->
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
<video id="hidden-video" style="display:none;" preload="auto"></video>

<script>
  const params = new URLSearchParams(window.location.search);
  const jobId  = params.get("job");

  const PHASES = ["MVP", "Strike", "Touch Down", "Full Support", "Mid Swing", "Toe Off"];

  // Fallback fixed offsets used when keypoint data is unavailable (old jobs).
  const PHASE_OFFSETS_FALLBACK = [0.0, 0.15, 0.25, 0.40, 0.65, 0.85];

  const loadingEl   = document.getElementById("loading");
  const loadingText = document.getElementById("loading-text");
  const errorEl     = document.getElementById("error-state");
  const errorText   = document.getElementById("error-text");
  const kinogramEl  = document.getElementById("kinogram");
  const video       = document.getElementById("hidden-video");

  function showError(msg) {
    loadingEl.classList.add("hidden");
    errorText.textContent = msg;
    errorEl.classList.add("visible");
  }

  // ‚îÄ‚îÄ Smoothing helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  function movingAvg(arr, w = 4) {
    return arr.map((_, i) => {
      const vals = [];
      for (let j = Math.max(0, i - w); j <= Math.min(arr.length - 1, i + w); j++) {
        if (arr[j] !== null && arr[j] !== undefined) vals.push(arr[j]);
      }
      return vals.length > 0 ? vals.reduce((a, b) => a + b, 0) / vals.length : null;
    });
  }

  // Central-difference velocity; positive = value increasing (foot descending in image coords)
  function centralDiff(arr) {
    return arr.map((v, i) => {
      if (i === 0 || i === arr.length - 1 || v === null) return 0;
      const prev = arr[i - 1] ?? arr[i];
      const next = arr[i + 1] ?? arr[i];
      return (next - prev) / 2;
    });
  }

  // ‚îÄ‚îÄ Local extrema ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  function localMaxima(arr) {
    const peaks = [];
    for (let i = 2; i < arr.length - 2; i++) {
      if (arr[i] === null) continue;
      if (arr[i] > (arr[i-1] ?? -Infinity) &&
          arr[i] > (arr[i+1] ?? -Infinity) &&
          arr[i] > (arr[i-2] ?? -Infinity) &&
          arr[i] > (arr[i+2] ?? -Infinity)) {
        peaks.push(i);
      }
    }
    return peaks;
  }

  function localMinima(arr) {
    const troughs = [];
    for (let i = 2; i < arr.length - 2; i++) {
      if (arr[i] === null) continue;
      if (arr[i] < (arr[i-1] ?? Infinity) &&
          arr[i] < (arr[i+1] ?? Infinity) &&
          arr[i] < (arr[i-2] ?? Infinity) &&
          arr[i] < (arr[i+2] ?? Infinity)) {
        troughs.push(i);
      }
    }
    return troughs;
  }

  // ‚îÄ‚îÄ Ankle-velocity phase detection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  /**
   * Returns { frames: [6 global frame indices], kinematic: bool }
   *
   * Algorithm (all indices are LOCAL to cycleFrames slice):
   *
   *  1. Extract ankle y-positions (image coords: higher y = lower = on ground).
   *  2. Smooth with a moving average to suppress YOLO jitter.
   *  3. Compute central-difference velocity (positive = foot descending).
   *  4. Find ground contact: the HIGHEST local maximum in ankle-y is the moment
   *     the foot is most firmly planted (deepest = Touch Down apex).
   *  5. Scan outward from that apex via velocity to find contact boundaries:
   *       ‚Äì scan backward  until velocity > threshold  ‚Üí Touch Down frame
   *       ‚Äì scan forward   until velocity < ‚àíthreshold ‚Üí Toe Off frame
   *  6. Derive remaining phases:
   *       Full Support = midpoint of contact period
   *       Strike       = ~50 ms before Touch Down (foot descending)
   *       Mid Swing    = first ankle local minimum after Toe Off (foot highest)
   *       MVP          = last secondary-ankle minimum before Strike (contralateral apex)
   *
   * Falls back to PHASE_OFFSETS_FALLBACK if data is missing or too sparse.
   */
  function detectPhaseFrames(frames, cycle, fps) {
    const { startFrame, endFrame, duration } = cycle;

    const fallback = () => ({
      frames: PHASE_OFFSETS_FALLBACK.map(off => startFrame + Math.round(off * duration)),
      kinematic: false,
    });

    if (duration < 6) return fallback();

    const cycleFrames = frames.slice(startFrame, Math.min(endFrame + 1, frames.length));
    if (!cycleFrames[0]?.kpts) return fallback();

    // 1. Extract ankle y-positions
    const rAnkY = cycleFrames.map(f => f.kpts?.rankle?.[1] ?? null);
    const lAnkY = cycleFrames.map(f => f.kpts?.lankle?.[1] ?? null);

    const countValid = arr => arr.filter(v => v !== null).length;
    const primaryY   = countValid(rAnkY) >= countValid(lAnkY) ? rAnkY : lAnkY;
    const secondaryY = countValid(rAnkY) >= countValid(lAnkY) ? lAnkY : rAnkY;

    if (countValid(primaryY) < 6) return fallback();

    // 2. Smooth
    const pS = movingAvg(primaryY,   4);
    const sS = movingAvg(secondaryY, 4);

    // 3. Velocity
    const pV = centralDiff(pS);

    // 4. Find ground-contact frame: highest ankle-y maximum
    const pMaxima = localMaxima(pS);
    if (pMaxima.length === 0) return fallback();

    const tdApex = pMaxima.reduce(
      (best, i) => (pS[i] > pS[best] ? i : best),
      pMaxima[0]
    );

    // 5. Scan for contact boundaries
    const halfWin  = Math.round(fps * 0.18); // max 180 ms either side
    const VEL_THR  = 0.8;                    // px/frame threshold

    let contactStart = tdApex;
    for (let i = tdApex - 1; i >= Math.max(0, tdApex - halfWin); i--) {
      if (pV[i] > VEL_THR) { contactStart = i + 1; break; }
      contactStart = i;
    }

    let contactEnd = tdApex;
    const fwdWin = halfWin + Math.round(fps * 0.06);
    for (let i = tdApex + 1; i < Math.min(pS.length, tdApex + fwdWin); i++) {
      if (pV[i] < -VEL_THR) { contactEnd = i - 1; break; }
      contactEnd = i;
    }

    // 6. Derive all six phase local indices
    const N     = cycleFrames.length - 1;
    const clamp = v => Math.min(Math.max(0, Math.round(v)), N);

    const touchDown   = clamp(contactStart);
    const fullSupport = clamp((contactStart + contactEnd) / 2);
    const toeOff      = clamp(Math.min(contactEnd + 2, N));
    const strike      = clamp(contactStart - Math.round(fps * 0.05));

    // Mid Swing: primary foot highest in air (min y) after toe-off
    const pMinima = localMinima(pS);
    const postToeMin = pMinima.filter(i => i > toeOff);
    const midSwing = clamp(
      postToeMin.length > 0
        ? postToeMin[0]
        : toeOff + Math.round(fps * 0.12)
    );

    // MVP: contralateral foot at apex (min y) before strike
    const sMinima = localMinima(sS);
    const preStrikeSec = sMinima.filter(i => i < contactStart);
    const mvp = clamp(
      preStrikeSec.length > 0
        ? preStrikeSec[preStrikeSec.length - 1]
        : Math.max(0, strike - Math.round(fps * 0.08))
    );

    console.log(
      `[Phase detect] MVP=${mvp} Strike=${strike} TD=${touchDown} ` +
      `FS=${fullSupport} MS=${midSwing} TO=${toeOff}  (local indices, cycle length=${N})`
    );

    return {
      frames: [mvp, strike, touchDown, fullSupport, midSwing, toeOff]
                .map(local => startFrame + clamp(local)),
      kinematic: true,
    };
  }

  // ‚îÄ‚îÄ Gait cycle detection (unchanged from original) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  function cleanSeries(frames, angleKey) {
    const raw = frames.map(f => (f.angles && f.angles[angleKey]) ?? null);
    for (let i = 0; i < raw.length; i++) {
      if (raw[i] !== null) continue;
      let before = i - 1;
      while (before >= 0 && raw[before] === null) before--;
      let after = i + 1;
      while (after < raw.length && raw[after] === null) after++;
      if (before >= 0 && after < raw.length)
        raw[i] = raw[before] + (raw[after] - raw[before]) * ((i - before) / (after - before));
      else if (before >= 0) raw[i] = raw[before];
      else if (after < raw.length) raw[i] = raw[after];
      else raw[i] = 0;
    }
    const out = [], w = 7;
    for (let i = 0; i < raw.length; i++) {
      let sum = 0, n = 0;
      for (let j = Math.max(0, i - w); j <= Math.min(raw.length - 1, i + w); j++) { sum += raw[j]; n++; }
      out.push(sum / n);
    }
    return out;
  }

  function findProminentPeaks(values, minDistFrames) {
    const candidates = [];
    for (let i = 2; i < values.length - 2; i++) {
      if (values[i] > values[i-1] && values[i] > values[i+1] &&
          values[i] > values[i-2] && values[i] > values[i+2]) {
        candidates.push(i);
      }
    }
    if (candidates.length === 0) return [];
    const globalMin = Math.min(...values), globalMax = Math.max(...values);
    const range = globalMax - globalMin || 1;
    const withProm = candidates.map(idx => {
      let leftMin = values[idx], rightMin = values[idx];
      for (let j = idx - 1; j >= 0; j--) { leftMin = Math.min(leftMin, values[j]); if (values[j] > values[idx]) break; }
      for (let j = idx + 1; j < values.length; j++) { rightMin = Math.min(rightMin, values[j]); if (values[j] > values[idx]) break; }
      return { idx, prominence: values[idx] - Math.max(leftMin, rightMin) };
    });
    const minProm = range * 0.15;
    const strong  = withProm.filter(p => p.prominence >= minProm).sort((a, b) => b.prominence - a.prominence);
    const selected = [];
    for (const peak of strong) {
      if (!selected.some(s => Math.abs(s - peak.idx) < minDistFrames)) selected.push(peak.idx);
    }
    return selected.sort((a, b) => a - b);
  }

  function detectGaitCycles(frames, angleKey, fps) {
    const smoothed = cleanSeries(frames, angleKey);
    const minDist  = Math.max(8, Math.floor(fps * 0.35));
    const peaks    = findProminentPeaks(smoothed, minDist);
    const cycles   = [];
    for (let i = 0; i < peaks.length - 1; i++) {
      const startFrame = peaks[i], endFrame = peaks[i + 1], duration = endFrame - startFrame;
      const durationSec = duration / fps;
      if (durationSec >= 0.25 && durationSec <= 2.0) cycles.push({ startFrame, endFrame, duration });
    }
    return cycles;
  }

  function evenlySpacedCycles(totalFrames, fps) {
    const start = Math.floor(totalFrames * 0.15), end = Math.floor(totalFrames * 0.85);
    const mid   = Math.floor((start + end) / 2);
    return [
      { startFrame: start, endFrame: mid, duration: mid - start },
      { startFrame: mid,   endFrame: end, duration: end - mid   },
    ];
  }

<<<<<<< HEAD
  // ‚îÄ‚îÄ Frame capture ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  function captureFrame(videoEl, time) {
    return new Promise((resolve, reject) => {
      const t = Math.max(0.05, Math.min(time, videoEl.duration - 0.05));
=======
  // ‚îÄ‚îÄ Capture a single frame from the video at a given time ‚îÄ‚îÄ
  // Uses double-rAF + delay to ensure the decoded frame is painted.
  function captureFrame(videoEl, time) {
    return new Promise((resolve, reject) => {
      const t = Math.max(0.05, Math.min(time, videoEl.duration - 0.05));

>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
      const timeout = setTimeout(() => {
        videoEl.removeEventListener("seeked", onSeeked);
        reject(new Error("Seek timeout at " + t.toFixed(3) + "s"));
      }, 10000);
<<<<<<< HEAD
      const onSeeked = () => {
        clearTimeout(timeout);
        videoEl.removeEventListener("seeked", onSeeked);
=======

      const onSeeked = () => {
        clearTimeout(timeout);
        videoEl.removeEventListener("seeked", onSeeked);

        // Wait 150ms for the decoder, then two rAF to ensure paint
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
        setTimeout(() => {
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              try {
                const canvas = document.createElement("canvas");
                canvas.width  = videoEl.videoWidth;
                canvas.height = videoEl.videoHeight;
                canvas.getContext("2d").drawImage(videoEl, 0, 0);
<<<<<<< HEAD
                resolve(canvas.toDataURL("image/jpeg", 0.85));
              } catch (e) { reject(e); }
=======
                console.log(`  ‚úì Captured: requested=${t.toFixed(3)}s actual=${videoEl.currentTime.toFixed(3)}s`);
                resolve(canvas.toDataURL("image/jpeg", 0.85));
              } catch (e) {
                reject(e);
              }
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
            });
          });
        }, 150);
      };
      videoEl.addEventListener("seeked", onSeeked);
      videoEl.currentTime = t;
    });
  }

  // ‚îÄ‚îÄ Fill a filmstrip row ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // phaseFrameIndices: array of 6 global frame indices, one per phase.

  async function fillRow(rowEl, phaseFrameIndices, fps) {
    const cells = rowEl.querySelectorAll(".frame-cell");
    for (let i = 0; i < phaseFrameIndices.length; i++) {
      const time = phaseFrameIndices[i] / fps;
      console.log(`  ${PHASES[i]}: frame ${phaseFrameIndices[i]}, time ${time.toFixed(3)}s`);
      try {
        const dataUrl = await captureFrame(video, time);
        const img     = document.createElement("img");
        img.src       = dataUrl;
        img.alt       = PHASES[i];
<<<<<<< HEAD
=======
        // Remove placeholder but keep scan-line
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
        const ph = cells[i].querySelector(".placeholder");
        if (ph) ph.remove();
        cells[i].insertBefore(img, cells[i].firstChild);
      } catch (e) {
        console.warn(`Failed to capture frame for ${PHASES[i]}:`, e);
      }
    }
  }

  // ‚îÄ‚îÄ Main ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  async function init() {
    if (!jobId) { showError("No job ID provided."); return; }

    let analysisOk = false;
    let fps = 30, totalFrames = 0, frames = [];
    let cycle1 = null, cycle2 = null;

    try {
      const res = await fetch(`/analysis-data/${jobId}`);
      if (res.ok) {
        const analysis = await res.json();
        fps    = analysis.fps || 30;
        frames = analysis.frames || [];
        totalFrames = frames.length;
        if (frames.length > 0) {
          analysisOk = true;
          const rCycles = detectGaitCycles(frames, "R Hip", fps);
          const lCycles = detectGaitCycles(frames, "L Hip", fps);
          if (rCycles.length > 0) cycle1 = rCycles[Math.floor(rCycles.length / 2)];
          if (lCycles.length > 0) {
            for (const lc of lCycles) {
              if (!cycle1 || Math.abs(lc.startFrame - cycle1.startFrame) > cycle1.duration * 0.3) {
                cycle2 = lc; break;
              }
            }
            if (!cycle2) cycle2 = lCycles[Math.floor(lCycles.length / 2)];
          }
          if (cycle1 && !cycle2 && rCycles.length > 1) {
            const idx = Math.floor(rCycles.length / 2);
            cycle2 = rCycles[idx + 1] || rCycles[idx - 1] || rCycles[0];
            if (cycle2 === cycle1 && rCycles.length > 1) cycle2 = rCycles[rCycles.length - 1];
          }
          if (!cycle1 && cycle2 && lCycles.length > 1) {
            const idx = Math.floor(lCycles.length / 2);
            cycle1 = lCycles[idx + 1] || lCycles[idx - 1] || lCycles[0];
          }
        }
      }
    } catch (e) {
      console.warn("Could not fetch analysis data:", e);
    }

<<<<<<< HEAD
    loadingText.textContent = "Downloading video‚Ä¶";
    try {
      const dlResp = await fetch(`/download/${jobId}`);
      if (!dlResp.ok) throw new Error("Download HTTP " + dlResp.status);
      const videoBlob = await dlResp.blob();
      const blobUrl   = URL.createObjectURL(videoBlob);
      loadingText.textContent = "Extracting frames‚Ä¶";
      await new Promise((resolve, reject) => {
        video.addEventListener("loadeddata", resolve, { once: true });
        video.addEventListener("error", () => reject(new Error("Failed to decode video.")), { once: true });
        video.src  = blobUrl;
=======
    // 2. Download the FULL video as a blob, then create an object URL.
    //    This guarantees the entire file is in memory and fully seekable ‚Äî
    //    the streaming proxy doesn't support HTTP Range requests, so
    //    a regular <video src="‚Ä¶"> can only decode from the start.
    const loadingText = document.querySelector(".loading-text");
    try {
      loadingText.textContent = "Downloading video‚Ä¶";
      const dlResp = await fetch(`/download/${jobId}`);
      if (!dlResp.ok) throw new Error("Download HTTP " + dlResp.status);

      // Read into blob
      const videoBlob = await dlResp.blob();
      const blobUrl   = URL.createObjectURL(videoBlob);

      loadingText.textContent = "Extracting frames‚Ä¶";

      await new Promise((resolve, reject) => {
        video.addEventListener("loadeddata", resolve, { once: true });
        video.addEventListener("error", () => reject(new Error("Failed to decode video.")), { once: true });
        video.src = blobUrl;
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
        video.load();
      });
    } catch (err) {
      console.error("Video load error:", err);
      showError("Failed to load the processed video.");
      return;
    }

<<<<<<< HEAD
    await new Promise(r => setTimeout(r, 500));
=======
    // Give the browser time to parse moov atom & build seek index
    await new Promise(r => setTimeout(r, 500));

>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
    console.log(`Video loaded: ${video.duration.toFixed(2)}s, ${video.videoWidth}x${video.videoHeight}`);

    if (!cycle1 && !cycle2) {
      const vidFrames = Math.floor(video.duration * fps);
      const fallback  = evenlySpacedCycles(vidFrames, fps);
      cycle1 = fallback[0]; cycle2 = fallback[1];
    }
    if (cycle1 && !cycle2) {
      const vidFrames = Math.floor(video.duration * fps);
      const start2    = Math.min(cycle1.endFrame + 2, vidFrames - 10);
      const end2      = Math.min(start2 + cycle1.duration, vidFrames);
      if (end2 - start2 > 4) cycle2 = { startFrame: start2, endFrame: end2, duration: end2 - start2 };
    }

    loadingEl.classList.add("hidden");
    kinogramEl.classList.add("visible");

    const row1El    = document.getElementById("filmstrip-row1");
    const row2El    = document.getElementById("filmstrip-row2");
    const row1Label = document.getElementById("row1-label");
    const row2Label = document.getElementById("row2-label");
    const row1Badge = document.getElementById("row1-badge");
    const row2Badge = document.getElementById("row2-badge");

    if (cycle1) {
      row1Label.childNodes[0].textContent = analysisOk ? "Stride 1 ‚Äî Right " : "Stride 1 ";
      const result1 = detectPhaseFrames(frames, cycle1, fps);
      if (result1.kinematic) {
        row1Badge.textContent = "KINEMATIC";
        row1Badge.className   = "detect-badge kinematic";
        // Highlight the phase label headers to signal they're computed, not estimated
        document.querySelectorAll("#phase-labels-row1 .phase-label").forEach(el => el.classList.add("detected"));
      }
      console.log("Row 1 phase frames:", result1);
      await fillRow(row1El, result1.frames, fps);
    }

    if (cycle2) {
      row2Label.childNodes[0].textContent = analysisOk ? "Stride 2 ‚Äî Left " : "Stride 2 ";
      const result2 = detectPhaseFrames(frames, cycle2, fps);
      if (result2.kinematic) {
        row2Badge.textContent = "KINEMATIC";
        row2Badge.className   = "detect-badge kinematic";
        document.querySelectorAll("#phase-labels-row2 .phase-label").forEach(el => el.classList.add("detected"));
      }
      console.log("Row 2 phase frames:", result2);
      await fillRow(row2El, result2.frames, fps);
    }

<<<<<<< HEAD
=======
    // Update status bar
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
    const statusInfo = document.getElementById("status-info");
    const dur = video.duration ? video.duration.toFixed(1) + "s" : "‚Äî";
    const res = video.videoWidth ? `${video.videoWidth}x${video.videoHeight}` : "";
    statusInfo.textContent = `${fps} fps  ¬∑  ${dur}  ¬∑  ${res}`;
  }

  init();
</script>

<<<<<<< HEAD
=======
<!-- Animated particle background -->
>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
<script>
(function() {
  const canvas = document.getElementById('bg-canvas');
  const ctx = canvas.getContext('2d');
  let w, h, particles, gridPhase = 0;
<<<<<<< HEAD
  function resize() { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; }
  window.addEventListener('resize', resize); resize();
=======

  function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
  const PARTICLE_COUNT = 60;
  particles = [];
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    particles.push({
<<<<<<< HEAD
      x: Math.random()*w, y: Math.random()*h,
      vx: (Math.random()-0.5)*0.3, vy: (Math.random()-0.5)*0.3,
      r: Math.random()*1.5+0.5, alpha: Math.random()*0.4+0.1,
      color: Math.random()>0.5 ? '0,245,255' : '99,102,241',
      pulse: Math.random()*Math.PI*2, pulseSpeed: Math.random()*0.02+0.005,
    });
  }
  function draw() {
    ctx.clearRect(0,0,w,h); gridPhase += 0.003;
    const gridSize=40, gridAlphaBase=0.025; ctx.lineWidth=0.5;
    for (let x=0; x<w; x+=gridSize) {
      const wave=Math.sin(x*0.005+gridPhase)*0.015+gridAlphaBase;
      ctx.strokeStyle=`rgba(0,245,255,${wave})`; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    }
    for (let y=0; y<h; y+=gridSize) {
      const wave=Math.sin(y*0.005+gridPhase*1.3)*0.015+gridAlphaBase;
      ctx.strokeStyle=`rgba(0,245,255,${wave})`; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    for (const p of particles) {
      p.x+=p.vx; p.y+=p.vy; p.pulse+=p.pulseSpeed;
      if (p.x<-10) p.x=w+10; if (p.x>w+10) p.x=-10; if (p.y<-10) p.y=h+10; if (p.y>h+10) p.y=-10;
      const pa=p.alpha*(0.6+0.4*Math.sin(p.pulse));
      ctx.beginPath(); ctx.arc(p.x,p.y,p.r*4,0,Math.PI*2); ctx.fillStyle=`rgba(${p.color},${pa*0.15})`; ctx.fill();
      ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fillStyle=`rgba(${p.color},${pa})`; ctx.fill();
    }
    ctx.lineWidth=0.5;
    for (let i=0; i<particles.length; i++) for (let j=i+1; j<particles.length; j++) {
      const dx=particles[i].x-particles[j].x, dy=particles[i].y-particles[j].y, dist=Math.sqrt(dx*dx+dy*dy);
      if (dist<120) {
        ctx.strokeStyle=`rgba(0,245,255,${(1-dist/120)*0.08})`; ctx.beginPath();
        ctx.moveTo(particles[i].x,particles[i].y); ctx.lineTo(particles[j].x,particles[j].y); ctx.stroke();
      }
    }
    requestAnimationFrame(draw);
  }
=======
      x: Math.random() * w,
      y: Math.random() * h,
      vx: (Math.random() - 0.5) * 0.3,
      vy: (Math.random() - 0.5) * 0.3,
      r: Math.random() * 1.5 + 0.5,
      alpha: Math.random() * 0.4 + 0.1,
      color: Math.random() > 0.5 ? '0,245,255' : '99,102,241',
      pulse: Math.random() * Math.PI * 2,
      pulseSpeed: Math.random() * 0.02 + 0.005,
    });
  }

  function draw() {
    ctx.clearRect(0, 0, w, h);
    gridPhase += 0.003;

    // Animated grid
    const gridSize = 40;
    const gridAlphaBase = 0.025;
    ctx.lineWidth = 0.5;
    for (let x = 0; x < w; x += gridSize) {
      const wave = Math.sin(x * 0.005 + gridPhase) * 0.015 + gridAlphaBase;
      ctx.strokeStyle = `rgba(0, 245, 255, ${wave})`;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, h);
      ctx.stroke();
    }
    for (let y = 0; y < h; y += gridSize) {
      const wave = Math.sin(y * 0.005 + gridPhase * 1.3) * 0.015 + gridAlphaBase;
      ctx.strokeStyle = `rgba(0, 245, 255, ${wave})`;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }

    // Particles
    for (const p of particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.pulse += p.pulseSpeed;
      if (p.x < -10) p.x = w + 10;
      if (p.x > w + 10) p.x = -10;
      if (p.y < -10) p.y = h + 10;
      if (p.y > h + 10) p.y = -10;

      const pulseAlpha = p.alpha * (0.6 + 0.4 * Math.sin(p.pulse));
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r * 4, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${p.color}, ${pulseAlpha * 0.15})`;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${p.color}, ${pulseAlpha})`;
      ctx.fill();
    }

    // Connections
    ctx.lineWidth = 0.5;
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const dx = particles[i].x - particles[j].x;
        const dy = particles[i].y - particles[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 120) {
          ctx.strokeStyle = `rgba(0, 245, 255, ${(1 - dist / 120) * 0.08})`;
          ctx.beginPath();
          ctx.moveTo(particles[i].x, particles[i].y);
          ctx.lineTo(particles[j].x, particles[j].y);
          ctx.stroke();
        }
      }
    }

    requestAnimationFrame(draw);
  }

>>>>>>> 8b579133d1b85f92bf1d6fb4ca860757b77c124f
  draw();
})();
</script>
</body>
</html>